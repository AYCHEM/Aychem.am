<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>

    <!-- Basic Page Needs
    ================================================== -->
    <meta charset="utf-8">
    <meta name="description" content="">
    <meta name="author" content="Brennan Novak">

    <!-- Mobile Specific Metas
    ================================================== -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!-- CSS - CHANGE URL when making live
    ================================================== -->
    <link rel="stylesheet" href="/css/mailpile.css">

    <!--[if lt IE 9]>
        <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Favicons
    ================================================== -->
    <link rel="shortcut icon" href="../img/favicon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/img/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/img/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/img/apple-touch-icon-114x114.png">
    <link rel="alternate" type="application/rss+xml" title="RSS" href="index.rss" />

    <title>Mailpile: Blog</title>

    <!-- JS ================================================== -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.flexnav.min.js"></script>
    <script src="/js/list.min.js"></script>
    <script src="/js/jquery.sortable.js"></script>
    <script src="/js/jquery.cookie.js"></script>
    <script src="/js/sjcl.js"></script>
    <script src="/js/hoipoi.js"></script>
    <script src="/js/site.js"></script>
</head><body>

    <div id="navigation">
      <div class="menu-button">Menu</div>
        <ul data-breakpoint="800" class="flexnav">
            <li><a href="/" class="scroll-link">About</a></li>
            <li><a href="/download/" class="scroll-link">Download</a></li>
            <li><a href="/faq/" class="scroll-link">FAQ</a></li>
            <li><a href="/demos/" class="scroll-link">Demos</a></li>
            <li><a href="/donate/" class="scroll-link">Donate</a></li>
            <li><a href="/blog/" class="scroll-link">Blog</a></li>
            <li class="navigation-github"><a href="http://github.com/pagekite/Mailpile" target="_blank" class="scroll-link">Github</a></li>
        </ul>
    </div>

    <a id="github-banner" href="https://github.com/pagekite/mailpile"><img style="position: absolute; top: 2.9em; right: 0; border: 0; z-index:4;" src="/img/forkme_right_red_aa0000.png" alt="Fork me on GitHub"></a>

    <div id="content" class="container">
        <div id="header" class="clearfix">
            <div class="col-2 text-center">
                <a href="/"><img class="pages-logo" src="/img/icon-120x120.png"></a>
            </div>
            <div class="col-12">
                <a href="/"><h2><strong>mail</strong>pile : blog</h2></a>
<!--            <h6>A modern, fast web-mail client with user-friendly encryption and privacy features. 100% Free and Open Source software</h6> -->
            </div>
        </div>
        <hr class="blog-hr">
        <div class="row"></div>

        <!-- Content -->
        <div id="pages" class="clearfix">
            <div class="col-13">
<!-- Page content begins -->

    <a href="2015-02-26_Revisiting_the_GnuPG_discussion.html"><h1>More thoughts on working with GnuPG</h1></a>
    <p><strong>Posted by <a href="#">Bjarni</a>
               on February 26, 2015</strong></p>
    <p>Smári's <a href="/blog/2014-10-07_Some_Thoughts_on_GnuPG.html">blog post on working with
GnuPG</a> got a fair bit of
attention and continues to be referenced in various posts and
discussions online.</p>
<p>Responses have varied, from vehement agreement, to a <a href="https://lists.gnupg.org/pipermail/gnupg-users/2015-February/052401.html">friendly and
thoughtful response from Werner
himself</a>,
to random folks on the Internet people calling us incompetent for using
the GnuPG command-line tool directly instead of some library or other.</p>
<p>I would like to address that last group specifically:</p>
<ol>
<li>
<p>If you think a command-line interface is not an API, then you are
   ignoring the millions of lines of shell scripts that keep the Internet
   running. You are wrong. Please consult your nearest sysadmin for an
   attitude readjustment.</p>
</li>
<li>
<p>Process separation is one of the cornerstones of good security
   design. Heartbleed and many other vulnerabilities are direct results
   of crypto and keys living the same process space as protocol and
   application logic. We initially chose to invoke GnuPG (and OpenSSL
   as well) as external tools for such security reasons, even though we
   knew it would cost us some performance.</p>
</li>
<li>
<p>We looked at the libraries, encountered an apalling lack of
   documentation and hoped the command-line interface would be nicer to
   work with. Learning one API beats having to learn two, and there was
   no way we could do this <em>without</em> the GnuPG CLI - if only for
   debugging and tech support reasons.</p>
</li>
</ol>
<p>Phew.</p>
<p>Now that I've gotten that off my chest... let's move on to some more
productive discussions!</p>
<h2>Utility or Application?</h2>
<p>Although I appreciated Werner's response to our post, I am afraid he
missed the forest for the trees. Probably because Smári wrote a lot
about some interesting, funky trees... :-)</p>
<p>Fundamentally, I think Mailpile's difficulties stem from the fact that
GnuPG was not written with automation in mind. The tool is not written
as a unix utility, it is very much written as a user facing application,
a tool for humans.</p>
<p>As such, it is a fantastic piece of engineering. If you understand how
public/private key encryption works and know what you want to do, odds
are GnuPG will help you get the job done. GnuPG's security track record
is solid and it is a tool people can rely on, as long as they take the
time to learn the basics and get used to the CLI.</p>
<p>However, as a result of this design focus, many of GnuPG's automation
interfaces appear to be an afterthought. They are incomplete and often
difficult to work with. Consider that "commands to create and sign keys
without any user interaction" were brand new <a href="http://lists.gnupg.org/pipermail/gnupg-announce/2014q4/000358.html">in GnuPG 2.1 last
November</a>.
GnuPG 2.1 is the development version of GnuPG and is not shipped by any
of the mainstream Linux distributions yet. I do applaud the fact that
these features are being added, but the fact that it happened 3 months
ago only supports my hypothesis: automation has to a great extent been
an afterthought to the GnuPG project.</p>
<p>This has gotten worse over time, not better. In GnuPG 2.0, use of
<code>gpg-agent</code> and <code>pinentry</code> became mandatory and the assumption that the
tool is running in a desktop environment under human oversight pervades.
This is why Linux distros still keep shipping GnuPG 1.4.x - they rely on
automated PGP processing for package verification and other things which
GnuPG 2.0 just isn't suitable for.</p>
<p>I worry that GnuPG 2.1 takes this even further still, <a href="https://www.gnupg.org/faq/whats-new-in-2.1.html">moving key
managment operations into the
agent</a>. Also, as far
as I can tell, it doesn't matter whether we use the <code>gpgme</code> library or
the command-line tool, those assumptions and behaviors are shared
throughout.</p>
<p>Much of this is understandable, given GnuPG's historic roots and the
fact that it inherits many things from it's predecessor, PGP, which
itself predated modern graphical desktops and web apps. It is also
understandable, given the culture around PGP, where keys and passphrases
are magical holy talismans, so special that you need to constantly ask
the user for permission before invoking them.  GnuPG enforces this
culture by preventing apps from interfering with the flow of this
critical information, refusing to work without trusted pinentry.</p>
<p>However, while GnuPG insists on controlling this part of the user
interface and treats automation as a 2nd class citizen, a side effect is
that the project actively thwarts efforts of others that want or need
alternate user interfaces.</p>
<p>Mailpile is one such project.</p>
<h2>Mailpile's pinentry woes</h2>
<p>One of the cool things about Mailpile, is it functions not only in a
desktop environment, but also as a background process (receiving,
decrypting and indexing mail), and also as a remote web server which
allows the user to leave their mail and keys on a secure box in their
home, which they then access remotely over the network.</p>
<p>This flexibility is key to our overall goals of providing people with
something that can match "cloud based" e-mail providers on features,
without compromising privacy and security.</p>
<p>Unfortunately, the entire pinentry concept, where <code>gpg</code> (via the
<code>gnupg-agent</code>) displays a window prompting the user to enter a
passphrase, is completely and utterly incompatible with this. Popping up
a dialog on the user's Raspberry Pi, when the owner tries to read
encrypted mail from halfway across the world using his Android phone's
web browser, is never going to work.</p>
<p>And even if it somehow did work, using a side-channel to authenticate
has very serious problems of its own.</p>
<p>Consider the situation where a user wants to access Mailpile both
locally, and remotely: on the desktop, the "just use pinentry" dogma
tells us we should just trust GnuPG there (and GnuPG 2.x enforces this
policy).</p>
<p>Well, what then happens when Mailpile is accessed remotely?</p>
<p>Things fail.</p>
<p>The benign failure mode is the user can't read encrypted mail because
they can't see the pinentry dialog. This makes the app unusable, but the
bug is still "benign" because it doesn't leak confidential data.</p>
<p>There is another catastrophic (and real) failure mode: If the legitimate
user is logged on at the desktop and an attacker can access Mailpile's
web interface at the same time, then the attacker will be able to read
encrypted mail (or compose fraudulent signed mail) because the
<code>gpg-agent</code> has keys cached and Mailpile has no way to communicate to
GnuPG that the remote access is somehow different from what happens
locally.</p>
<p>This is really, really bad.</p>
<p>This is why Mailpile only supports GnuPG 1.4.x at the moment: we haven´t
figured out how to make GnuPG 2.x operate in a secure fashion, since it
won't let us disable the agent.</p>
<p>This whole issue has us scratching our heads and wondering what to do.
We've gone from frustration to righteous anger, to just being rather
worried. If the GnuPG project is moving aggressively in a direction
which is fundamentally incompatible with projects like ours, what should
we do?  Drop PGP and try to implement S/MIME? Switch to something
interesting but unproven, like
<a href="http://www.tedunangst.com/flak/post/reop">reop</a>?</p>
<p>I just don't know.</p>
<p>I could come up with some clever hacks to work around GnuPG's core
design; I could implement my own agent, I could try to cripple GnuPG
with weird environment variables or a custom GNUPG_HOME and config, or I
could even fork the project - but those <em>all</em> feel like last resorts.</p>
<p>I am currently revisiting whether I can get <code>gpgme</code>-based code to avoid
the problems caused by the agent and side-channel auth. I am not too
optimistic. If that fails, then it's last resort time, or time to drop
PGP.</p>
<h2>Is this fixable?</h2>
<p>For the record, Mailpile is not the only project having problems -
questions about related issues are common <a href="https://lists.gnupg.org/pipermail/gnupg-users/2015-February/052754.html">on the GnuPG-users mailing
list</a>
and <a href="https://stackoverflow.com/questions/8671099/how-to-bypass-pinentry-passphrase-screen-while-decrypting-a-file-using-gpgme">elsewhere</a>.</p>
<p>However, I have yet to hear any of the GnuPG developers acknowledge that
this is even a concern, which is why I have taken the time to write this
post. I would like to humbly request that Werner and GnuPG consider
these issues, now that <a href="http://www.propublica.org/article/the-worlds-email-encryption-software-relies-on-one-guy-who-is-going-broke">they finally have a
budget</a>.
(Congrats, by the way, you deserve it!)</p>
<p>I really do think this can be fixed, if the GnuPG project agrees it is
worth doing. Some specific ideas that I think could help:</p>
<ol>
<li>
<p>Clearly separate the user interface aspects of GnuPG from the crypto
   and keychain management, so projects can use one without the other.
   Do not assume all apps interacting with a particular keychain want the
   same UI for authentication.</p>
</li>
<li>
<p>Treat the command-line interface of <code>gpg</code> as if it were an API; keep
   it stable and machine friendly. There should be command-line
   alternatives to all of the interactive dialogs.</p>
</li>
<li>
<p>Make <code>gpgme-tool</code> (which implements an API very similar to the JSON
   API requested by Smári in his post) a mandatory 1st class citizen of
   all GnuPG bundles (instead of <a href="https://lists.gnupg.org/pipermail/gnupg-devel/2014-December/029196.html">doing this</a>).
   We had no idea this tool existed, and I still can't find it for my
   distro (Ubuntu 14.04). Consider rolling this functionality into the
   <code>gpg</code> binary itself to facilitate scripting and automation.</p>
</li>
</ol>
<p>There are probably more, but those are my top three!</p>
<p>Thanks for reading, I look forward to further discussions (most likley
<a href="https://lists.gnupg.org/pipermail/gnupg-users/2015-February/052771.html">on the GnuPG Users mailing
list</a>).</p>
  <hr>
    <a href="2015-01-20_Mailpile_Beta_II_4096_bits.html"><h1>Mailpile Beta II - the 4096 bit release</h1></a>
    <p><strong>Posted by <a href="#">The Team</a>
               on January 20, 2015</strong></p>
    <p><img src="/files/Beta-II.jpg" border="0"></p>
<p>Hello world and Happy New Year!</p>
<p>The Mailpile team is happy to announce our second Beta release:
<strong>Mailpile Beta II</strong> (version 0.4.2). We're still not at 1.0 (sorry...),
but much progress has been made and it is high time to update our public
offerings again.</p>
<p>There was also a little security bug in the Beta, that we need to talk
about and address... but first, the good stuff!</p>
<h2>Where Can You Get It?</h2>
<p>The new release is availble from <a href="/download/">the Mailpile download
page</a>, and the source is <a href="https://github.com/mailpile/Mailpile/releases">on
github</a> as always.</p>
<p>Please read <a href="https://github.com/mailpile/Mailpile/wiki/Release-Notes-201501-Beta-II">the release
notes</a>
and check our <a href="https://github.com/mailpile/Mailpile/wiki/Security-roadmap">security
roadmap</a> so
you know what to expect.</p>
<p><strong>Note:</strong> People upgrading from the older Mac or Windows packages may
want to uninstall the old Mailpile Beta before installing Beta II. Your
data should all remain intact.</p>
<h2>What's New?</h2>
<p>Since our last beta, work has been focused on three things: fixing bugs,
improving the usability of PGP and speeding up the web interface.</p>
<p>We have made great progress on all of these fronts.</p>
<p>In particular, many of the bugs in our IMAP implementation have been
ironed out, as has the notorious bug whereby <code>openssl</code> processes stick
around consuming large amounts of CPU after Mailpile had supposedly been
shut down. Most of the bugs that made the command line interface
unusable were fixed and of course that security issue which we'll
discuss at the end of this post.</p>
<p>The usability of our PGP interface was given some serious scrutiny, with
the help of our friends at the Open Internet Tools project. The amazing
<a href="https://openitp.org/sup/">Gus Andrews</a> conducted a series of usability
studies with various types of users, the results of which were <a href="https://openitp.org/field-notes/user-tests-mailpile-features.html">posted
on the OpenITP's
blog</a>.
Brennan has been working on solutions based on this feedback and many
improvements in Mailpile Beta II are a result of this work. Thank you
Gus and OpenITP! We hope to work more with them in the future - this is
just the beginning!</p>
<p>Finally, Bjarni went into hiding in Italy to focus on improving the
performance of our web interface. As a result the Beta II release is
noticably snappier than the first Beta, and we expect more improvements
on this front in the near future.</p>
<p>Many other things are still in progress, including a more "AJAXy" user
interface, a way to safely read HTML mail, a redesign of the way
Mailpile stores its data, reductions in Mailpile's RAM requirements and
code cleanups to make Mailpile more amenable to Linux distro packaging.
Those features may not be visible in the Beta II user interface, but
people who look under the hood will find traces in the code.</p>
<h2>Our PGP key size bug</h2>
<p>That brings us to the security issue which forced us to get our act
together and push this release out the door:</p>
<p><em>The Mailpile Beta was misconfigured to generate weak PGP keys during
setup.</em></p>
<p>To be exact, if a user installed Mailpile and did not already have a PGP
key in their GnuPG keychain, then Mailpile would automatically generate
a new key. Instead of generating a 4096 bit encryption key as we had
planned, we actually generated a 1024 bit key. Oops!</p>
<ul>
<li><strong>How did this happen?</strong><br />
  Human error. The key size was lowered to facilitate debugging, and we forgot to raise it again.</li>
<li><strong>Who is affected?</strong><br />
  People who did not already have a PGP key and installed the Mailpile Beta, or installed from github before Jan 5, 2015.</li>
<li><strong>What is the impact?</strong><br />
  Unless you have powerful enemies, a 1024 bit key is still probably okay. See below for more details.</li>
<li><strong>How does one fix it?</strong><br />
  Generate a new key, revoke the old one. We have added code to Mailpile to assist with this process. Details below...</li>
</ul>
<p>We'd like to give special thanks to Matt Drollette for sending us a pull
request on github to fix the issue.</p>
<h3>So how bad is it really?</h3>
<p>Realistically, there still aren't many organizations in the world that
can factor 1024 bit keys within a reasonable amount of time. The NSA
certainly can. Its partners probably. Some other large organizations
maybe. There are some attacks that have worked to reduce the keyspace,
but they're more common on SSL than PGP. So unless your attacker is a
large powerful government, 1024 is probably okay-ish at the moment. And
using a 1024 bit key is certainly far, far better than not using
encryption at all.</p>
<p>On the other hand, PGP encrypted data tends to stay encrypted that way
for long periods of time, so there is a possibility that somebody could
intercept the encrypted message, store it until factoring 1024 bit RSA
keys is easy, and then decrypt it. That could be anything between years
or decades.</p>
<p>A lot of people still use 1024 bit RSA keys, but <a href="http://www.symantec.com/page.jsp?id=1024-bit-migration-faq">Certificate
Authorities stopped selling new 1024 bit certificates at the end of
2013</a>,
because they're simply not good enough.</p>
<p>Long story short: This isn't the end of the world, but we recommend you
upgrade your keys as soon as possible.</p>
<h3>How do you fix it?</h3>
<p>For that matter, how do you even know if you have a weak key?</p>
<p>These two questions are closely related, and just writing instructions
for all the different operating systems out there seemed like a daunting
task. So, in order to simplify the process, the Mailpile Beta II
includes code which will evaluate your keychain and suggest improvements
if it finds problems.</p>
<p>These problems are not limited to weak 1024 bit keys, the checker will
also detect other problems, such as using a key that is scheduled to
expire in the near future, or neglecting to create a key for one of your
outgoing e-mail addresses.</p>
<p>To give the tool a try, visit the Mailpile command-line interface and
run the <code>crypto/gpg/check_keys</code> command. It should produce output
similar to this:</p>
<pre class="add-bottom">
mailpile> crypto/gpg/check_keys

Sanity checked: 4 keys in GPG keyring, 1 profiles.
 - 61A015763D28D410A87B197328191D9B3B4199B4: OK: 4096 bits, looks good!
 - 85EE5D9223806DFCBA630E39EABBE96FD521D78C: --- Disabled.
 - 20FF41634DF6F90ECA4452203CAC6CA6E4D9C373: Bad: expired on 2015-01-16
 - 9858665AC3CA84FEAE2BCAD1E623001E05CE8B43: --- Disabled.

Proposed fixes:
 - Revoke bad keys:
    * Run: `gpg --gen-revoke 20FF41634DF6F90ECA4452203CAC6CA6E4D9C373`
    * Follow the instructions given
    * A block of text will be shown on your screen.
    * Send that block to contacts that have your key.
    * You can search for `is:encrypted to:me` to find people who have it.
- Disable bad keys:
    * Run: `gpg --edit-key 20FF41634DF6F90ECA4452203CAC6CA6E4D9C373`
    * Type `disable`
    * Type `save`
    * You're done!
</pre>

<p>The recommended <code>gpg</code> commands can be run either from a bash shell (or
C: prompt on Windows), or from within Mailpile itself - in order to
allow the instructions to work cross-platform we provide direct access
to <code>gpg</code> from within the Mailpile command-line itself.</p>
<p>We are sorry this is not more user friendly, but we had to strike a
balance between making things easy, and getting the word out as soon as
posible. Future versions of Mailpile will hopefully automate more of
this process, detect more problems, and make our "GPG keychain Doctor"
more accessible to people not used to using the command-line.</p>
<p>It's a start!</p>
<h2>Conclusion</h2>
<p>Thanks for reading this far, and thank you again for all of your
support.</p>
<p>Now go <a href="https://github.com/mailpile/Mailpile/wiki/Release-Notes-201501-Beta-II">check out Mailpile Beta II</a>!</p>
  <hr>
    <a href="2014-11-21_To_PGP_MIME_Or_Not.html"><h1>To PGP/MIME or not to PGP/MIME</h1></a>
    <p><strong>Posted by <a href="#">Bjarni</a>
               on November 21, 2014</strong></p>
    <p><strong>TL;DR</strong>: PGP/MIME has some serious flaws. I propose specifying an
alternative method for PGP-encrypting e-mail (including attachments)
which improves security while being backwards compatible with legacy
ad-hoc PGP encryption, air-gaps and webmail plugins.</p>
<h3>How does e-mail encryption work?</h3>
<p>The world of e-mail encryption can be surprisingly complicated and
convoluted.</p>
<p>The two standards that we have concentrated on the most in Mailpile, are
OpenPGP (<a href="https://tools.ietf.org/html/rfc4880">RFC4880</a>) and the
PGP/MIME (<a href="https://tools.ietf.org/html/rfc3156">RFC3156</a>) standard which
describes how to encrypt multi-part e-mail messages using OpenPGP.</p>
<p>In addition to PGP/MIME, there is also the older "ad-hoc" way of sending
encrypted content, which is to simply attach PGP-encrypted files as
attachments or to paste ASCII-armored blobs of encrypted text into the
message body itself.</p>
<p>To illustrate the difference, a PGP/MIME encrypted message with a single
attachment looks a bit like this:</p>
<pre class="add-bottom">
  |  From: Alice &lt;a1234@wonderland.com&gt;
  |  To: Bob &lt;b9973@builders.com&gt;
  |  Cc: Jar Jar Binks &lt;omgwtf@lucasfilm.com&gt;
  |  Subject: I have a secret
  |  Content-Type: multipart/encrypted;
  |                protocol="application/pgp-encrypted";
  |                boundary="==12345=="
  |
  |  --==12345==
  |  Content-Type: application/pgp-encrypted
  |  Content-Disposition: attachment
  |
  |  Version: 1
  |
  |  --==12345==
  |  Content-Type: application/octet-stream
  |  Content-Disposition: attachment; filename="msg.asc"
  |
  |  -----BEGIN PGP MESSAGE-----
  |  Version: GnuPG v1
  |
  E  Content-Type: multipart/mixed; boundary="==67890=="
  E
  E  --==67890==
  E  Content-Type: text/plain; charset='utf-8'
  E
  E  I am not wearing any socks!!
  E
  E  --==67890==
  E  Content-Type: image/jpeg
  E  Content-Disposition: attachment; filename="my-toes.jpg"
  E
  E  [BASE64 ENCODED PICTURE OF NAUGHTY TOES]
  E  --==67890==--
  |  -----END PGP MESSAGE-----
  |
  |  --==12345==--
</pre>

<p>The clear-text bits are preceded with a '|' and the contents of the
encrypted part with an 'E'. The same message, sent using ad-hoc
encryption, might look like this:</p>
<pre class="add-bottom">
  |  From: Alice &lt;a1234@wonderland.com&gt;
  |  To: Bob &lt;b9973@builders.com&gt;
  |  Cc: Jar Jar Binks &lt;omgwtf@lucasfilm.com&gt;
  |  Subject: I have a secret
  |  Content-Type: multipart/mixed; boundary="==12345=="
  |
  |  --==12345==
  |  Content-Type: text/plain; charset='utf-8'
  |
  |  -----BEGIN PGP MESSAGE----
  |  Digest: sha-1
  |
  E  I am not wearing any socks!!
  |  -----END PGP MESSAGE----
  |
  |  --==67890==
  |  Content-Type: application/octet-stream
  |  Content-Disposition: attachment; filename="my-toes.jpg.pgp"
  |
  E  [BASE64 ENCODED, PGP-ENCRYPTED PICTURE OF NAUGHTY TOES]
  |  --==67890==--
</pre>

<p>There are noticable differences here:</p>
<ol>
<li>The PGP/MIME encrypted data is formatted as a fragment of MIME data</li>
<li>The PGP/MIME encrypted message hides how many parts the message has
   and any metadata about them: an outsider cannot tell whether there
   is an attachment or not.</li>
<li>In the ad-hoc scheme, only the payloads are encrypted</li>
<li>The ad-hoc scheme loses the mime-type of the attachment</li>
<li>The ad-hoc scheme leaks the name of the attachment in the clear (or
   loses it, if it gives the attachment a nondescript name)</li>
<li>The ad-hoc scheme does not protect the integrity of the message, an
   attacher can inject parts or remove parts without Bob being able to
   detect that anything happened.</li>
</ol>
<h3>What does this all mean?</h3>
<p>When the technical characteristics of the two formats are compared, there
are two major considerations - security and compatibility.</p>
<p>For ad-hoc encryption, we find:</p>
<ol>
<li>Ad-hoc encryption is not very secure: it leaks or loses metadata, and
   message integrity is not guaranteed.</li>
<li>Ad-hoc encryption is comptible with legacy mail clients, in that it
   allows the recipient to manually copy all the encrypted parts and
   decrypt "offline", giving them the opportunity to communicate with some
   security even though their mail client does not understand PGP.</li>
</ol>
<p>Conversely:</p>
<ol>
<li>PGP/MIME encryption protects attachment metadata and message structure,
   only the message header is sent in the clear.</li>
<li>In practice, PGP/MIME is not compatible with legacy mail clients. If
   a user saves and manually decrypts the payload, they will end up with
   a fragment of MIME-encoded data. Tools for working with fragments of
   MIME are not widely available, so for non-technical users the data is
   effectively worthless.</li>
</ol>
<h4>What does this mean for Mailpile?</h4>
<p>When trying to design and deploy a user-friendly e-mail encryption tool,
we can't just consider the interface we present to our own users, we
also have to consider the experience of people receiving our mail. If
it's illegible, then we have a problem - and that is exactly what is
happening here. If we stick with the more secure PGP/MIME, then it's
guaranteed that our outgoing messages will be unreadable by a
significant number of users, even if they have PGP keys and know how to
use them.</p>
<p>Just to clarify, Mailpile absolutely needs to be able to receive and
correctly parse PGP/MIME formatted mail. That is not up for debate - all
secure mail clients should do this, just like all web browsers should
parse and display GIF images. But if better alternatives are available
to us, we probably should avoid creating new content using a format that
is known to have fundamental flaws.</p>
<h4>What is the impact?</h4>
<p>Most desktop and some mobile mail clients do support PGP/MIME, but few
do so natively - most require a 3rd party plugin, which is a usability
concern in and of itself.</p>
<p>When we consider the vast number of webmail users, the situation is much
more grim - there a recipient's only option is a variation of the manual
download scenario; save attachments and decrypt offline. Webmail
encryption plugins, Mailvelope and Google's End-To-End being the most
promising at the moment, are merely automating that process and generally
<a href="https://code.google.com/p/end-to-end/#Which_RFCs_does_End-To-End_support?">do not support PGP/MIME</a>.
Although <a href="https://code.google.com/p/end-to-end/issues/detail?id=32">Google's engineers have expressed interest in supporting
PGP/MIME eventually</a>,
<a href="https://github.com/mailvelope/mailvelope/issues/41">as have Mailvelope's</a>,
it is not an easy problem and they make no promises about when or how.</p>
<p>Finally, there is a very small, but disproportionatly important, set of
users (whistle-blowers, activists, spies) who have a need to run their
Internet tools and their encryption tools on separate machines.  An "air
gap" is a low-tech, widely understood method of protecting secret key
material from being compromised. If we send PGP/MIME formatted mail,
air-gapping becomes inconvenient to the point of being infeasible.</p>
<p>Since usable crypto is our goal, and Mailpile users need to be able to
communicate with people using other mail clients, I feel that real-world
compatibility is marginally more important than dogmatically adhering to
standards and protocols.</p>
<p>And by that logic, the question changes...</p>
<h3>Can ad-hoc PGP encryption be made as secure as PGP/MIME?</h3>
<p>I think maybe it can.</p>
<p>The problems with ad-hoc encryption (aside from the fact that it is
not very elegant), are as follows:</p>
<ul>
<li>Metadata is leaked or lost</li>
<li>Message integrity is not guaranteed</li>
</ul>
<p>Here are a couple strategies to deal with this:</p>
<ol>
<li>Put all attachments in a ZIP archive, and encrypt that.</li>
<li>Add an encrypted "Email Manifest" which verifies message integrity
   and carries metadata.</li>
</ol>
<p>These methods could be combined, or used separately. They are
complementary, but the Email Manifest is actually the more important of
the two.</p>
<p>Putting attachments in an archive would largely be a matter of
convenience for the recipient, as it allows us to stop transmitting
file-names in the clear, while allowing the user to use standard, well
understood tools to interact with the contents. Without such an archive,
we either have to transmit file names in the clear, or ask users to
rename files by hand.</p>
<p>The Email Manifest is the more interesting part of this proposal. It not
only allows us to verify the integrity of the message, it also gives us
the opportunity to correct some of the more egregious deficiencies of
PGP/MIME - namely the fact that PGP/MIME transmits the Subject, From,
To, CC and many other critical headers in the clear. PGP/MIME is also
annoyingly picky and ambiguous about how to treat white-space when
verifying signatures.</p>
<p>Mail clients implementing some sort of "Email Manifest protocol" could
agree to move critical headers out of the main message and into the
encrypted manifest as often as possible, and then reverse the same
process upon decryption. We can make sure the Email Manifest's
specification deals with white-space in a clear and easy to implement
manner.</p>
<h4>Another example</h4>
<p>To revisit our example, an e-mail sent using an Email Manifest approach
might look like this:</p>
<pre class="add-bottom">
  |  From: a1234@wonderland.com
  |  To: b9973@builders.com
  |  Cc: omgwtf@lucasfilm.com
  |  Subject: Encrypted Message
  |  Content-Type: multipart/mixed; boundary="==12345=="
  |
  |  --==12345==
  |  Content-Type: text/plain; charset='utf-8'
  |
  |  -----BEGIN PGP MESSAGE----
  |  Digest: sha-1
  |
  E  From: Alice
  E  To: Bob
  E  Cc: Jar Jar Binks
  E  Subject: I have a secret
  E
  E  I am not wearing any socks!!
  E
  E  Note: this message should have 1 attachment and a manifest.
  |  -----END PGP MESSAGE----
  |
  |  --==67890==
  |  Content-Type: application/octet-stream
  |  Content-Disposition: attachment; filename="attachment-1.pgp"
  |
  E  [BASE64 ENCODED, PGP-ENCRYPTED PICTURE OF NAUGHTY TOES]
  |  --==67890==
  |  Content-Type: application/pgp-manifest
  |  Content-Disposition: attachment; filename="manifest.pgp"
  |
  E  Manifest-Version: 1.0
  E  From: Alice &lt;a1234@wonderland.com&gt;
  E  To: Bob &lt;b9973@builders.com&gt;
  E  Cc: Jar Jar Binks &lt;omgwtf@lucasfilm.com&gt;
  E  Subject: I have a secret
  E
  E  Inline: text/plain; sha2sum="..."; has-pgp; pgp-has-hints
  E  Attachment-1: image/jpeg; filename="my-toes.jpg"; sha2sum="..."
  |  --==67890==--
</pre>

<p>This sample demonstrates how both the message structure and sensitive
headers could be moved into the Email Manifest.</p>
<p>This example does not use a ZIP archive, so it leaks how many
attachments the mail has and how big they are; building an example
which does use a ZIP archive is left as an exercise for the reader.</p>
<p>For the benefit of PGP-enabled mail clients unaware of the Manifest,
some important header data and human readable integrity hints could be
injected into the text part itself, while an Email Manifest-aware
client could suppress the duplicate information automatically to avoid
clutter.</p>
<h4>What does the recipient see?</h4>
<p>If a recipient's mail client understands Email Manifests, the message
can be rendered just as nicely as if it were sent using PGP/MIME, with
the added benefit that protected headers can be marked as secure.</p>
<p>A PGP-aware mail client that doesn't understand the Manifest will see
simplified headers, and the text-part of the e-mail will have some extra
clutter at the top, From, To, Subject etc, and a notice at the bottom.
The attachments may need to be renamed or extracted from a ZIP archive
before they are useful. They will also see the Email Manifest itself as
an attachment, which they can decrypt and read if they would like to
manually confirm the message was delivered intact.</p>
<p>A mail client with no support for PGP, will present the user with
encrypted text and attachments they can save to disk for offline
processing.</p>
<p>So compared to PGP/MIME, this approach improves the security of Mailpile
users (or others supporting Email Manifests), makes life somewhat less
convenient for the users of other PGP/MIME-aware mail software, and
dramatically improves interoperability with mail clients and plugins
that do not understand PGP/MIME, including webmail users.</p>
<h3>Conclusion</h3>
<p>It is definitely possible to transmit PGP-encrypted messages and
attachments over e-mail in a way which is both more interoperable and
more secure than the PGP/MIME format.</p>
<p>The question remains - should we?</p>
<p>This is not a standard, but perhaps it could become one. Messages sent
this way have the potential to be more secure than PGP/MIME, but some of
the features of PGP/MIME will be lost; namely mail-client awareness of
attachment types and probably also support for HTML mail. However, that
may only be a short-term problem, until PGP plugins are upgraded to
understand Email Manifests.</p>
<p>Is the ZIP archive idea good or bad? It makes some things easier and
both hides and preserves more metadata, but it complicates
implementation and may add extra steps for the recipent. On the other
hand, manually renaming files is no fun and ZIP files may be the lesser
of two evils if we assume we are indeed abandoning PGP/MIME.</p>
<p>We would like to get feedback on this from people who work with
encrypted e-mail on a day to day basis, security trainers and such
folks, and from folks writing secure e-mail tools. What do you think?
Please mail us at <a href="mailto:team@mailpile.is">team@mailpile.is</a> or tweet
at <a href="https://twitter.com/MailpileTeam">@MailpileTeam</a> if you have
insights to share.</p>
<p>We'll also be following <a href="https://news.ycombinator.com/item?id=8648587">comments on Hacker News</a>.</p>
<p>Thanks!</p>
  <hr>
    <a href="2014-10-07_Some_Thoughts_on_GnuPG.html"><h1>Some thoughts on working with GnuPG</h1></a>
    <p><strong>Posted by <a href="#">Smári</a>
               on October 7, 2014</strong></p>
    <p>A lot of people have complained about OpenPGP for a number of valid cryptographical reasons<a href="http://blog.cryptographyengineering.com/2014/08/whats-matter-with-pgp.html">1</a>,<a href="http://secushare.org/PGP">2</a>. It doesn't change the fact that it is widely used, and wildly useful. It urgently needs to be replaced with something more sensible, but for now we're stuck with it. In practice, this also means that we are stuck with GnuPG, the most common and by far the best implementation of OpenPGP.</p>
<p>GnuPG is the one and only reference implementation of <a href="http://tools.ietf.org/html/rfc4880">RFC 4880</a>, and despite thousands of companies making use of OpenPGP in their infrastructre there is for all intents and purposes a solitary dude in Germany trying to keep it all together. <a href="http://werner.eifelkommune.de/">Werner Koch</a> is an absolute hero for managing to do that, and deserves our respect and support. Financially supporting the GnuPG project is also something people should be doing. </p>
<p>The following is however neccessary and hopefully constructive criticism of GnuPG.</p>
<p>One of the things I'm largely to blame for in Mailpile is the GnuPG interface. It's a chunk of Python code that executes the GnuPG binary, tosses information at it, and figures out what to do with the output. There are lots of libraries for doing this, but after a great deal of exploration I found that all of the Python libraries that did this were insufficient for our needs, and the only thing crazier than manually forking out GnuPG in our situation would be to use the PGPME library.</p>
<p>PGPME is almost as confusing and annoying as calling GnuPG directly, but it also requires us to ship architecture-specific libraries to everybody, something we're actively avoiding. Having to ship GnuPG binaries to Windows and MacOS users is bad enough, but dependency hell is a place we want to stay out of. If we were writing Mailpile in, say, C or C++, then PGPME would definitely be the library of choice, but we're not, so it isn't. On top of that, the available <a href="http://pyme.sourceforge.net/">Python bindings for PGPME</a> are very flaky (last updated in 2008!), and not developed or maintained by the GnuPG team.</p>
<p>As a result, we've got a roughly 1200 line chunk of code in Mailpile that has the fun and useful task of chatting with GnuPG, and the stupifyingly annoying task of working around all of GnuPG's inconsistencies.</p>
<p>The problems with GnuPG seem to fall roughly into two broad categories: inconsistent output structure, inconsistent interfaces. These are both ripe with surprising behaviour and confusing failure modes. In addition to these categories, it appears that the larger meta problem is that no single statement about its problems is going to remain a stable statement, as these problems disappear and reappear at odd intervals as new versions are being built. The number of moving parts essentially leads to a lot of confusion about whether a particular bug exists in a particular version or not, and whether it is affected by wind speed. To wit, I have over the course of Mailpile development added, removed, and readded a workaround for a bug, although I think I'm safe to say that it does not exist post GnuPG 2.1. The comment of that workaround in the code illustrates the issue perfectly:</p>
<pre class="add-bottom">
def list_secret_keys(self):
       #
       # Note: The "." parameter that is passed is to work around a bug
       #       in GnuPG < 2.1, where --list-secret-keys does not list
       #       details about key capabilities or expiry for
       #       --list-secret-keys unless a selector is provided. A dot
       #       is reasonably likely to appear in all PGP keys, as it is
       #       a common component of e-mail addresses (and @ does not
       #       work as a selector for some reason...)
       #
       #       The downside of this workaround is that keys with no e-mail
       #       address or an address like alice@localhost won't be found.
       #       Therefore, this paramter should be removed when GnuPG >= 2.1
       #       becomes commonplace.
       #
       #       (This is a better workaround than doing an additional
       #       --list-keys and trying to aggregate it though...)
       #
       #       BRE: Put --fingerprint at the front and added selectors
       #            for the worlds MOST POPULAR LETTERS!  Yaaay!
       #
       retvals = self.run(["--fingerprint",
                           "--list-secret-keys", ".",
                           "--list-secret-keys", "a",
                           "--list-secret-keys", "e",
                           "--list-secret-keys", "i",
                           "--list-secret-keys", "p",
                           "--list-secret-keys", "t",
                           "--list-secret-keys", "k"])
       return self.parse_keylist(retvals[1]["stdout"])
</pre>

<p>This bug exists in the first category:</p>
<h3>Inconsistent output structure</h3>
<p>GnuPG <em>generally</em> accepts command line parameters, uses these to perform actions, and returns output. The output generally takes two forms:</p>
<ol>
<li>Line by line descriptive output, such as when listing keys</li>
<li>Bulk output, such as when encrypting, decrypting, or signing</li>
</ol>
<p>The line-by-line output has two modes, the normal mode where the data is tabulated with spaces into mostly nice, if somewhat confusing columns, and the <code>--with-colons</code> mode, where the spaces are replaced with colons, for easy parsing. This is quite clever and good. The problem arises when one intends to start parsing this data.</p>
<p>First, a word on discoverability. If you ever intend to do anything with GnuPG, you first need to read and internalize a document aptly titled <code>DETAILS</code>, which contains a lot of the details about what's going on with GnuPG output. I have dutifully read, memorized chunks of, and bookmarked this file for posterity. It is immensely helpful. For example, it gives an example of GnuPG's output:</p>
<pre class="add-bottom">
$ gpg --with-colons --list-keys \
      --with-fingerprint --with-fingerprint wk@gnupg.org
pub:f:1024:17:6C7EE1B8621CC013:899817715:1055898235::m:::scESC:
fpr:::::::::ECAF7590EB3443B5C7CF3ACB6C7EE1B8621CC013:
uid:f::::::::Werner Koch <wk@g10code.com>:
uid:f::::::::Werner Koch <wk@gnupg.org>:
sub:f:1536:16:06AD222CADF6A6E1:919537416:1036177416:::::e:
fpr:::::::::CF8BCC4B18DE08FCD8A1615906AD222CADF6A6E1:
sub:r:1536:20:5CE086B5B5A18FF4:899817788:1025961788:::::esc:
fpr:::::::::AB059359A3B81F410FCFF97F5CE086B5B5A18FF4:
</pre>

<p>In order to decipher what this all means, you need to refer to rest of the document. This shows the <code>--with-colons</code> format, which is the way we want to be working with it.</p>
<p>Now here comes issue the first: this is essentially a colon separated value (CSV!) data structure, but the data being provided is a) inconsistent, and b) structured.</p>
<p>Notably, the first output line says "there is a public key," and the line after it says "here is a fingerprint." Naively one might think that these are unrelated. But in fact, all of the lines from the one starting with <code>pub</code> up to the next one that starts with either <code>pub</code> or <code>sec</code> are actually details about the nature of the public key mentioned in the <code>pub</code> line - although to make things worse, the <code>fpr</code> lines after the <code>sub</code> lines refer to the <code>sub</code> line but not the <code>pub</code> line. Confused yet?</p>
<p>In reality, parsing this isn't too terrible, but it can only be done in a reasonable way if you understand the structure of PGP keys and the output format of GnuPG. These are <em>not</em> reasonable assumptions for GnuPG to be making. Even armed with knowledge about the structure of keys and the handy <code>DETAILS</code> document, my first version of a parser was overly generic and terribly inefficient, because I kept trying to avoid inconsistencies.</p>
<p>Now, the inconsistencies start to get exciting around about here.</p>
<p>Notice these two lines:</p>
<pre class="add-bottom">
pub:f:1024:17:6C7EE1B8621CC013:899817715:1055898235::m:::scESC:
fpr:::::::::ECAF7590EB3443B5C7CF3ACB6C7EE1B8621CC013:
</pre>

<p>These both follow the same output format, according to <code>DETAILS</code>. But look what happens when I add spaces to align the columns:</p>
<pre class="add-bottom">
pub:f:1024:17:6C7EE1B8621CC013:899817715:1055898235::m:                                        ::scESC:
fpr: :    :  :                :         :          :: :ECAF7590EB3443B5C7CF3ACB6C7EE1B8621CC013:
</pre>

<p>Some of the columns are meaningless for some of the output lines, but more shockingly, some of the columns are MISSING sometimes. Three of the columns just simply evaporate if the line is an <code>fpr</code>-type line. On top of that, there's no really good reason why the fingerprint needs to be a separate output line rather than just being added in at the right place. According to the <code>DETAILS</code> file, field 10 is for "User ID" - which is to say, the name, e-mail address, and comment associated with the key. Things that the fingerprint emphatically is not.</p>
<p>It this point you'll notice that field 5 contains the Key ID. And for added pain, the key ID is variously the last 8 or the last 16 nibbles (hexadecimal digits) of the fingerprint.</p>
<p>Frustrated yet? Me too. But let's just wave the rest of this category away, and move on to the next:</p>
<h3>Inconsistent interfaces</h3>
<p>So let's imagine you want to generate a key. Sounds like a reasonable thing to do, right? So we're all hip and cool and want to do so programatically with our shiny command line interface to GnuPG, so naturally we think it'll look something like:</p>
<pre class="add-bottom">
$ gpg --gen-key --name Smári McCarthy --email smari@mailpile.is --algorithm RSA --keysize 4096 --expires 2017-10-06
</pre>

<p>... or something to that effect. And have sensible defaults for any parameters that are skipped, or otherwise make them required. Right?</p>
<p>Wrong.</p>
<p>GnuPG does have a <code>--gen-key</code> flag, but when you call it you are dropped into an interactive interface where you are forced to answer questions, one at a time. In varying order, depending on the version, it seems.</p>
<p>The only sensible programmatic way to deal with this is to use "expect" style scripts, where your script captures the output and provides programmatic input depending on what the application last said. These used to be used a lot in the 80's, but have fallen out of favour because: a) they make internationalization a nightmare, b) they make changing versions of software a nightmare, and c) they are almost never the right way to do anything.</p>
<p>They do work though. Kind of. Until they break, and it'll be hell to debug them.</p>
<p>Now, avid users of GnuPG will at this point mention the <code>--batch</code> option, which allows in this case for providing options to the key generator in yet another format. Except, of course, that if you want to do something entirely reasonable like add more than one UID (for instance if you have multiple e-mail addresses) to a new key, you can't. <code>--batch</code> just doesn't support it.</p>
<p>So your options are to either painfully generate through using expect-style scripts, or use batch and then edit the key afterwards to add uids. Except that the <code>--edit-key</code> also relies on an interface which requires the use of expect-style scripts, so you just gained nothing.</p>
<p>Another thing that frequently happens when using encryption software with slow algorithms (such as secure pseudorandom number generation or RSA) is that you have to wait a long time for things to happen. When you're making software with nice user interfaces, you sometimes start thinking that showing some kind of intermediate progress would be a nice thing to do. This is where we get to GnuPG's wonderful status file descriptor.</p>
<p>Really, the status descriptor is awesome. It gives me lots of information that is valuable and can make life a lot better. There are however a few shortcomings. First, contrary to all other file descriptors that you may work with in GnuPG, the status descriptor is not guaranteed to give you a newline character at the end of a status, which renders a bunch of sensible methods of reading input from it unreliable and requires that I handle that descriptor with special magic. Nor are you strictly guaranteed to only get statuses. I have on occasion run into blank lines and other weirdness that needs to be stripped. Once those quirks are all managed, the status descriptor is actually invaluable and should not be overlooked -- specially when mixed with the <code>--enable-progress-filter</code> flag.</p>
<p>The biggest complaint about the status descriptor is that it cannot be relied upon as a flow control mechanism. It does not always give output, or indicate the appropriate sequence of things, so an interface can use it for the purpose of increasing their information about the current situation, but not as a replacement for constant reading and parsing of the STDOUT and STDERR handles, and certainly not as a replacement for in-depth understanding of which order things happen in.</p>
<p>Actually, it should also be mentioned that as nice as it is to have all these descriptors, heavy use of descriptors turns into a world of problems on Windows. Windows is finicky enough as it is. Our solution was passing the status through to STDERR, which really works kind of fine.</p>
<p>Speaking of order, consider this handling of the passphrase descriptor -- a special descriptor for accepting a passphrase sent by the user as part of a wrapper-mediated communication (because nobody ever uses pipes like that on the command line), from GnuPG's <code>gpg.c</code>:</p>
<pre class="add-bottom">
    ...
    if( pwfd != -1 )  /* Read the passphrase now. */
    read_passphrase_from_fd( pwfd );
    ...
    switch (cmd)
      {
      case aPrimegen:
      case aPrintMD:
      ...
</pre>

<p>The interesting thing (aside from the annoying and dangerous lack of indentation on that if statement) is the way in which the passphrase is read from the password descriptor before the commands are managed. Which is to say, the passphrase <em>must</em> be sent, and, due to the way read_passphrase_from_fd is written, that descriptor closed on the sending end, before <em>anything</em> else happens. Which means that you need to know at the time of execution of the GnuPG binary that you need to send a passphrase, if you are going to do so programatically. This gives you three options: a) Send it every single time (requires storing the passphrase on the calling side, typically in insecure memory), b) Be willing to execute the same command twice, capturing potential errors on the first try and figuring out that they are due to a lack of passphrase -- something the error message will not always be clear about, or c) keep track of the entirety of GnuPG's internal state, which would be absolutely insane, even if it weren't version dependent. </p>
<p>This behaviour is not obvious, or particularly reasonable, let alone documented. Figuring this out took a long time. </p>
<p>If you've seen Mailpile's Windows and MacOS releases, you'll have noticed that we are shipping slightly old versions of GnuPG. The reason for this is that we figured out pretty late that the passphrase-fd is not the correct way to do things and has been disabled in more recent versions of GnuPG in favour of expanded use of things that implement the gpg-agent mechanism. So Mailpile should be a gpg-agent. </p>
<p>(It is notable that several distributions still have GnuPG 1.4 as the default instead of GnuPG 2.x...)</p>
<p>The reason for this is that Mailpile provides a web interface, and in some of its use cases, it will do so from a server which is not necessarily capable of rendering a GTK window or provide a terminal prompt on the user's device. So despite all of the reasons why people might not want to shift a PGP passphrase over a SSL connection, it might still be something people will want to do, and we need to be ready for that contingency. So we need to accept the passphrase through a web form, and pass it back to GnuPG one way or another. (Note: the generic case is Mailpile running on localhost, which is always a fine thing to do. Even over HTTP. Normal threat model limitations apply.)</p>
<p>All of this is weird and annoyingly inconsistent. This category of problems probably doubled our interface in size and complexity, and made error handling an absolute nightmare. </p>
<h3>The Error Handling Issue</h3>
<p>When writing a library like this, we need to be able to anticipate errors from GnuPG and respond appropriately. The number of different and confusing ways of receiving information also means that there are a number of different and confusing ways to receive error statuses and such. Sometimes the return value is useful, but frequently it is not. Sometimes there is something on the status descriptor, or on STDERR. Often both, sometimes neither. The entire thing is maddening.</p>
<p>The approach we've had to take is the opposite of what would be preferable. It is simply to check if the positive output we're getting from GnuPG is roughly of the sort that we were expecting, and assume that if it isn't, an error has occurred. As a general error handling strategy this is idiotic, we know, and we'd like it to stop.</p>
<h3>What can be done?</h3>
<p>The short answer is the same as <a href="http://blog.cryptographyengineering.com/2014/08/whats-matter-with-pgp.html">Matt Green's answer</a>: It is time for PGP to die -- or rather, RFC 4880 needs to be cleaned up, simplified, and replaced. PGP in its current form needs to evolve. There are a lot of very good reasons why, which <a href="http://secushare.org/PGP">Carlos has neatly catalogued</a>. But realistically, PGP is what people use for e-mail, and until we have widespread adoption of crypto in e-mail <em>at all</em>, trying to replace PGP is just going to cause painful fragmentation. Since one of Mailpile's goals is to get millions of people encrypting their e-mail by default, we can't risk this fragmentation right now. If we round to the closest <a href="http://en.wikipedia.org/wiki/Lakh">lakh</a>, zero people currently encrypt their e-mail. This is <a href="http://smarimccarthy.is/blog/2014/05/27/big-silos-small-privacy/">scary</a> and <a href="http://smarimccarthy.is/blog/2014/05/28/engineering-our-way-out-of-fascism/">bad</a>. The way forward is not to throw PGP out, but to start thinking seriously about what replaces RFC 4880.</p>
<p>But we're stuck with RFC 4880. For now. A standard that is, for better or worse, being maintained entirely by one man.</p>
<p>Which gives us four options:</p>
<ol>
<li>Stick with GnuPG and improve it substantially.</li>
<li>Fork GnuPG and improve it substantially.</li>
<li>Replace GnuPG with something simpler and more consistent.</li>
<li>Give up.</li>
</ol>
<p>None of those approaches is good. I'm going to take option four off the table immediately because we're not going to give up.</p>
<p>Option two is essentially the hostile version of option one, so I'll write it off immediately. The people who've been developing GnuPG are great and we really like them. So we won't be forking GnuPG anytime soon -- heck, even if we did want to do that, we'd still not have any time to actually work on it.</p>
<p>Option three sounds most sensible long-term. Cruft is unavoidable, but Google's End-to-End might potentially serve as the basis for "minimum viable PGP". But End-to-End is also written in Javascript, and while people are entirely free to call me old-fashioned, I'd like the GnuPG replacement to be written in a compiled systems language.</p>
<p>But long term is long term. Short term, the only option is to stick with GnuPG.</p>
<p>I'd therefore like to propose the following:</p>
<h3>GnuPG JSON Mode</h3>
<p>As I mentioned, a lot of GnuPG's output is actually structured a lot more than the output format supports. In our work so far, we've managed to build reasonable JSON structures out of that output for a lot of things. Completing that work and expanding on it, it would be possible to support something like this:</p>
<pre class="add-bottom">
 $ gpg --json '{query}'
 {response1}
 {response2}
 ...
 {responseN}
</pre>

<p>This would be relatively easy to build atop of GnuPG's current source code, making the <code>--json</code> flag preempt all else in the way <code>--batch</code> currently does. Then it uses a well supported library to parse the query, figure out what it is doing, call the appropriate internal functionality, and return the right data structures, also JSON encoded.</p>
<p>In order to support intermediate results, status descriptor style, an arbitrary number of results is allowed. They need not be comma separated, because we want our input parser to be able to pick them up one by one. Rather, just end each response block with a newline.</p>
<p>Have GnuPG exit after the last response.</p>
<p>With this, anybody implementing a GnuPG interface will be able to do all the magic relatively easily. The data structures can be well documented. Everything can become easy. I will stop losing my hair.</p>
<p>Somebody might ask, what about PGPME? Frankly, PGPME is great for a particular subset of GnuPG users. They can keep using it if they want. But if <code>--json</code> exists and is consistent and comprehensive, everybody will use that. Trust me.</p>
<h3>Conclusion</h3>
<p>GnuPG is important and great in many ways, but it is also deeply broken and downright dangerous. The sooner it becomes a consistent tool, the sooner it will become something other than a fool's errand to attempt to interface with it. I'm happy to be on the caravan of fools for now, but only if there is something worthwhile at the end of this quest.</p>
<p>Software is hard. Security software is harder. Werner is doing great at managing a very shit situation, created by RFC 4880. I think there is a real possibility to make GnuPG way better. For now, we need JSON mode. I'm sure crowdfunding this work is possible, because we need it. I for one will put some cash down for this bounty. Join me?</p>
<p><strong>Update:</strong> <a href="/blog/2015-02-26_Revisiting_the_GnuPG_discussion.html">We have written a follow-up
post</a>.</p>
  <hr>

  <h3>Older stuff</h3>
  <ul>
    <li><a href="2014-09-13_Mailpile_Beta_Release.html">One Year Later: Mailpile Beta</a></li>
    <li><a href="2014-08-20_Upcoming_Beta_Release_Part_II.html">Our Upcoming Beta Release: Part II</a></li>
    <li><a href="2014-08-08_Our_Upcoming_Beta_Release.html">Our Upcoming Beta Release</a></li>
    <li><a href="2014-06-03_Mailpile_Alpha_II.html">Mailpile Alpha II - The Dogfood Edition</a></li>
    <li><a href="2014-04-30_Where_is_the_Community_Site.html">Where is the Community Site?</a></li>
    <li><a href="2014-04-07_Workshop_in_London.html">Mailpile Workshop in London</a></li>
    <li><a href="2014-02-07_IndieGoGo_Update_8.html">Development, Perks, and Alpha (IGG Update #8)</a></li>
    <li><a href="2014-01-31_Alpha_Release_Shipping_Bits_and_Atoms.html">Alpha Release: Shipping Bits and Atoms</a></li>
    <li><a href="2014-01-12_A_Plan_For_Spam.html">A Plan For Spam ... and Bacon!</a></li>
    <li><a href="2013-11-23_A_Pound_of_Security.html">A Pound of Security</a></li>
    <li><a href="2013-11-18_Speaking_your_language.html">Speaking Your Language</a></li>
    <li><a href="2013-11-01_IndieGoGo_Update_7.html">Perks? What perks? (IGG Update #7)</a></li>
    <li><a href="2013-10-31_DarkMail_and_Secure_Protocols.html">DarkMail and Secure Protocols</a></li>
    <li><a href="2013-10-11_The_Month_of_Dog_Fooding.html">The Month of Dog Fooding</a></li>
    <li><a href="2013-09-12_IndieGoGo_Update_6.html">Thank you! (IGG Update #6)</a></li>
    <li><a href="2013-09-11_Budget_and_Roadmap.html">A Rough Budget and Alpha Roadmap</a></li>
    <li><a href="2013-09-10_Surveillance_Centralization.html">Surveillance And Centralization (video)</a></li>
    <li><a href="2013-09-10_IndieGoGo_Update_5.html">The Home Stretch (IGG Update #5)</a></li>
    <li><a href="2013-09-06_IndieGoGo_Update_4.html">PayPal News (IGG Update #4)</a></li>
    <li><a href="2013-09-05_PayPal_Freezes_Campaign_Funds.html">PayPal Freezes Campaign Funds</a></li>
    <li><a href="2013-09-05_IndieGoGo_Update_3.html">PayPal News (IGG Update #3)</a></li>
    <li><a href="2013-08-30_Fonts_and_Copyright_Licenses.html">Fonts and Copyright Licenses</a></li>
    <li><a href="2013-08-21_IndieGoGo_Update_2.html">We are funded! (IGG update #2)</a></li>
    <li><a href="2013-08-20_Turning_Money_Into_Code.html">Turning Money Into Code</a></li>
    <li><a href="2013-08-15_Digging_Through_the_Details.html">Digging Through the Details</a></li>
    <li><a href="2013-08-11_IndieGoGo_Update_1.html">Our first week (IGG update #1)</a></li>
    <li><a href="2013-08-11_Designing_Security.html">Designing Security (video)</a></li>
    <li><a href="2013-08-08_Mailpile_Launched.html">Mailpile Launched</a></li>
  </ul>


<!-- Page content ends -->
                <p><script id='fbwj89d'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=mailpile&button=compact&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=20;f.width=110;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fbwj89d');</script></p>
                <hr>
            </div>
        </div>
        <!-- Contact & Media -->
        <div id="footer" class="clearfix">
            <div class="one-third">
                <h3>Please Donate</h3>
                <p>To ensure future development and growth of Mailpile and our community!</p>
                <p><a href="/donate/" target="_blank"><img src="/img/donate-button.png" style="width: 60%;"></a></p>
            </div>
            <div class="one-third">
                <h3>Contact Us</h3>
                <ul class="add-bottom">
                    <li>Email: <a href="mailto:team@mailpile.is">team@mailpile.is</a></li>
                    <li>Twitter: <a href="https://twitter.com/mailpileteam" target="_blank">@MailpileTeam</a></li>
                    <li>Facebook: <a href="https://facebook.com/mailpile" target="_blank">Mailpile</a></li>
                    <li>IRC freenode: <a href="irc://irc.freenode.net/#mailpile">#mailpile</a></li>
                    <li>Tor: <a href="http://clgs64523yi2bkhz.onion/">clgs64523yi2bkhz.onion</a></li>
                </ul>
            </div>
            <div class="one-third">
                <h3>Downloads</h3>
                <ul class="add-bottom">
                    <li>Source Code: <a href="https://github.com/pagekite/Mailpile" target="_blank">Github</a></li>
                    <li>Bugs, Issues: <a href="https://github.com/pagekite/Mailpile/issues/new" target="_blank">Go Here</a></li>
          <li>Ideas: <a href="https://github.com/pagekite/Mailpile/issues?milestone=2&state=open" target="_blank"> Go Here</a></li>
          <li>Plugin Ideas: <a href="https://github.com/pagekite/Mailpile/issues?milestone=6&state=open" target="_blank"> Go Here</a></li>
                    <li>Original Font: <a href="https://github.com/mailpile/fonts" target="_blank">Mailpile "the font"</a></li>
        </ul>
                <ul>
                    <li>Logo: <a href="/img/mailpile-logo.svg" target="_blank">Color Vector (SVG)</a></li>
                    <li>Logo: <a href="/img/mailpile-logo.png" target="_blank">Color (PNG)</a></li>
                </ul>
            </div>
        </div>

        <div class="add-top add-bottom"></div>


    </div><!-- container -->

</body>
</html>